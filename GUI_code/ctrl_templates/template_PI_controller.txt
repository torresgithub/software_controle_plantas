///////////////////////////////////////////////////////////////////
// Implemente o calculo da acao de controle aqui.
//
// Variaveis que voce pode usar (jah estao disponiveis):
//
//   t           -> tempo [s]
//   ctrl_last_t -> ultimo instante de tempo em que o
//                  codigo do controlador foi executado [s].
//                  Obs.: (t - ctrl_last_t) deve ser bem proximo
//                  do intervalo de controle = 10ms.
//
//   ym          -> vetor de sinais medidos: ym[0] a ym[3]:
//                  ym[0] = posicao em [graus].
//                  ym[1] = velocidade angular [graus/s].
//
//
//   ref         -> vetor de sinais de referencia: ref[0].
//
//   u           -> vetor de sinais de entrada da planta u[0].
//
//   xc          -> vetor de estados do controlador
//                  (inicializados com valor zero): xc[0] a xc[5].
//                  Use para implementar um controlador
//                  dinamico, ao inves de um estatico.

// Controlador: PI

// Erro [graus]:
float e;

// Intervalo amostragem para controle (10ms):
const float Ts = 10.0e-3;

// Ganho proporcional em [unidades PWM/grau]:
const float kp = 1.5f;

// Tempo integral em [s]:
const float Ti = 10.0f;

// Ensaio em malha fechada: usa o valor de comando PWM,
// alterado via interface grafica, como sinal de referencia
// em [graus]:
ref[0] = RefSteps.get(t);

// Calculo do erro:
e = ref[0] - ym[0];

// Calculo da acao de controle.
// Note que uma variavel de estado interna do controlador
// serah usada para armazenar a integral do erro, calculada
// usando a regra de Euler. Voce pode implementar
// estrategias que contam com ateh 6 variaveis de estado:

u[0] = kp*(e + 1/Ti*xc[0]);
xc[0] = xc[0] + Ts*e;


